from config.imports import *
from config.settings import YEARLY_PLANS
from config.tooltip import ToolTip
from config.utils import load_icon_image, add_icon_image


class YearlyPlans(tk.Frame):
    """
    A class that represents the Yearly Plans page in the application. This page allows the user to view,
    create, edit, and delete yearly plans.
    """
    def __init__(self, parent, main_window):
        """
        Initializes the YearlyPlans page with the provided parent, main window.

        :param parent: The parent widget for this frame.
        :param main_window: The main window of the application.
        """
        super().__init__(parent)
        self.image_load_count = 0
        self.configure(bg=INTERFACE['bg_color'])
        self.main_window = main_window
        self.parent = parent
        self.main_window.disable_buttons()

        self.year_buttons = []
        self.years_list = []
        asyncio.run(self.fetch_years_from_server())

        self.icon_photo = asyncio.run(load_icon_image(SERVER_URL, ICONS_PATHS['yearly_plans'], VERIFY_ENABLED))

        add_source_label(self, ICONS_PATHS['yearly_plans'], PAGES_NAMES['yearly_plans'],
                         bg_color=INTERFACE['bg_color'], font=INTERFACE['source_label_font'])

        # Banner add
        self.banner_label, self.banner_image_original = add_banner(
            self,
            banner_path=BANNER_PATHS['yearly_plans'],
            bg_color=INTERFACE['bg_color']
        )

        # resize_banner
        if self.banner_label and self.banner_image_original:
            self.bind("<Configure>", lambda event: resize_banner(
                self,
                self.banner_label,
                self.banner_image_original
            ))

        add_icon_and_label(self, text=PAGES_NAMES['yearly_plans'], icon_path=ICONS_PATHS['yearly_plans'],
                           bg_color=INTERFACE['bg_color'])

        add_separator(self, INTERFACE['separator'])
        self.add_quote_and_image()
        self.load_year_buttons()

    async def fetch_years_from_server(self):
        """
        Fetches the list of years from the server.

        This function sends an asynchronous GET request to the server endpoint
        to retrieve available years. The response is expected to be a JSON
        array where each item contains a "year" field.

        Updates:
        - Populates `self.years_list` with the retrieved years.

        Handles:
        - Raises an exception if the request fails or the server response is invalid.

        Returns:
        - None
        """
        url = f"{SERVER_URL}/get_years"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, ssl=SSL_ENABLED) as response:
                    response.raise_for_status()
                    data = await response.json()
                    self.years_list = [item["year"] for item in data]
        except Exception as e:
            print(f"Error loading years data: {e}")

    def bind_right_click_to_buttons(self):
        """
        Binds the right-click (Button-3) event to each year button. When a button is right-clicked,
        it triggers the context menu (typically for editing or deleting the year).

        :return: None
        """
        for button in self.year_buttons:
            button.bind("<Button-3>", lambda event, button=button: self.show_context_menu(event, button))

    def show_context_menu(self, event, year_button):
        """
        Displays a context menu when a right-click (Button-3) event occurs on a year button.
        The menu includes options to edit or delete the selected year.

        :param event: The event object generated by the right-click.
        :param year_button: The button representing the year that was right-clicked.
        :return: None
        """
        context_menu = tk.Menu(self, tearoff=0)  # Context menu

        context_menu.add_command(label="Edit", command=lambda: self.edit_year(year_button),
                                 font=YEARLY_PLANS['menu_font'])
        context_menu.add_command(label="Delete", command=lambda: asyncio.run(self.delete_year(year_button)),
                                 font=YEARLY_PLANS['menu_font'])

        # Show menu
        context_menu.post(event.x_root, event.y_root)

    def edit_year(self, year_button):
        """
        Opens a window for editing the year on the selected year button. The user can input a new year.

        :param year_button: The button representing the year to be edited.
        :return: None
        """
        old_year = int(year_button.cget("text"))  # Get current year from button

        edit_window = tk.Toplevel(self)
        edit_window.withdraw()
        edit_window.title("Edit Year")

        center_window_on_parent(self.main_window, edit_window, 300, 200)
        edit_window.iconbitmap(APP['icon_path'])

        label = tk.Label(edit_window, text="Enter the new year:", font=YEARLY_PLANS['toplevel_windows_font'])
        label.pack(padx=10, pady=10)

        # New year entry
        year_entry = tk.Entry(edit_window, font=YEARLY_PLANS['toplevel_windows_font'])
        year_entry.pack(padx=10, pady=10)
        year_entry.focus_set()
        year_entry.bind("<Return>",
                        lambda event: asyncio.run(self.submit_year_edit(year_entry.get(), old_year,
                                                                        year_button, edit_window)))

        # Save button
        submit_button = tk.Button(edit_window, text="Save",
                                  command=lambda: asyncio.run(self.submit_year_edit(year_entry.get(), old_year,
                                                                                    year_button, edit_window)),
                                  font=YEARLY_PLANS['save_button_font'])
        submit_button.pack(padx=10, pady=10)
        submit_button.config(cursor="hand2")

        # Cancel button
        cancel_button = tk.Button(edit_window, text="Cancel", command=edit_window.destroy,
                                  font=YEARLY_PLANS['cancel_button_font'])
        cancel_button.pack(padx=10, pady=5)
        cancel_button.config(cursor="hand2")

        edit_window.deiconify()

    async def submit_year_edit(self, new_year_str, old_year, year_button, edit_window):
        """
        Submits the edited year to the server and updates the UI accordingly.

        This function is called when a user submits an updated year. It validates the new year, checks if it exists
        in the list of years, and then sends the request to the server to update the year. If successful, the UI is updated
        with the new year and the years list is modified.

        Args:
            new_year_str (str): The string representation of the new year entered by the user.
            old_year (int): The old year (before the edit) displayed on the year button.
            year_button (tk.Button): The button associated with the year, whose text will be updated after a successful edit.
            edit_window (tk.Toplevel): The window that will be closed after the successful update.

        Returns:
            None. This function performs actions based on the response from the server and modifies the UI directly.

        Raises:
            messagebox (tkinter messagebox): Displays error or success messages based on the outcome of the operation.
        """
        if new_year_str.isdigit():
            new_year = int(new_year_str)

            if new_year in self.years_list:
                messagebox.showerror("Error", f"Year {new_year} already exists.")
                edit_window.lift()
                return

            data = json.dumps({"old_year": old_year, "new_year": new_year})

            async with aiohttp.ClientSession() as session:
                async with session.put(f"{SERVER_URL}/edit_year", data=data,
                                       headers={"Content-Type": "application/json"},
                                       ssl=SSL_ENABLED) as response:
                    if response.status == 200:
                        year_button.config(text=str(new_year))
                        year_button.config(command=lambda: self.open_year_page(new_year))

                        self.years_list.remove(old_year)
                        self.years_list.append(new_year)

                        messagebox.showinfo("Success", f"Year updated to {new_year}")
                        edit_window.destroy()

                    elif response.status == 404:
                        messagebox.showerror("Error", "Old year not found.")
                    elif response.status == 409:
                        messagebox.showerror("Error", f"Year {new_year} already exists.")
                    else:
                        messagebox.showerror("Error", "Failed to update year.")
        else:
            messagebox.showerror("Error", "Invalid year entered.")

    async def delete_year(self, year_button):
        """
        Deletes the year after confirming with the user.

        This function is called when a user wants to delete a year. It first asks for user confirmation, and if confirmed,
        sends the request to the server to delete the year. On success, the UI is updated by removing the year button
        and updating the internal list of years.

        Args:
            year_button (tk.Button): The button associated with the year to be deleted.

        Returns:
            None. This function performs actions based on the response from the server and modifies the UI directly.
            It also shows confirmation and error messages based on the outcome of the operation.

        Raises:
            messagebox (tkinter messagebox): Displays confirmation or error messages to the user.
        """
        year = int(year_button.cget("text"))

        confirm = messagebox.askyesno("Delete Year", f"Are you sure you want to delete year {year}?")
        if not confirm:
            messagebox.showinfo("Cancel", "Year deletion cancelled.")
            return

        data = json.dumps({"year": year})

        async with aiohttp.ClientSession() as session:
            async with session.delete(f"{SERVER_URL}/delete_year", data=data,
                                      headers={"Content-Type": "application/json"},
                                      ssl=SSL_ENABLED) as response:
                if response.status == 200:
                    messagebox.showinfo("Success", f"Year {year} deleted.")
                    self.year_buttons = [btn for btn in self.year_buttons if btn != year_button]
                    year_button.destroy()

                    self.years_list = [y for y in self.years_list if y != year]

                elif response.status == 404:
                    messagebox.showerror("Error", "Year not found.")
                else:
                    messagebox.showerror("Error", "Failed to delete year.")

    def load_year_buttons(self):
        """
        Loads the year buttons from the server and displays them in the interface in reverse order.

        This function will read the years from the server and create buttons for each year, displaying them
        starting from the most recent year. If the file does not exist or is empty, no buttons will be created.

        :return: None
        """
        self.year_buttons_frame = tk.Frame(self, bg=INTERFACE['bg_color'])
        self.year_buttons_frame.pack(pady=5)

        self.years_list.reverse()

        for year in self.years_list:
            if year is not None:
                year_button = tk.Button(
                    self.year_buttons_frame,
                    text=str(year),
                    command=lambda y=year: self.open_year_page(y),
                    image=self.icon_photo,
                    compound=tk.LEFT,
                    font=YEARLY_PLANS['year_buttons_font']
                )
                year_button.pack(side=tk.TOP, pady=5)
                year_button.config(cursor="hand2")

                # Tooltip for right-click instructions
                ToolTip(year_button, "Right click to edit/delete")
                self.year_buttons.append(year_button)

        # Bind right-click events to the buttons
        self.bind_right_click_to_buttons()

        self.check_image_load_count()

    def check_image_load_count(self):
        """
        Checks the image load count and enables the buttons when it reaches 1.
        This function is called periodically until the condition is met.
        """
        if self.image_load_count >= 1:
            # If image load count is 1 or greater, enable the buttons
            self.main_window.enable_buttons()
        else:
            # If not, check again after a short delay (100ms)
            self.after(100, self.check_image_load_count)

    def add_quote_and_image(self):
        """
        Adds a quote and an image to the user interface, along with a pin label and an "Add Year" button.

        This function creates the following elements:
        - A frame to hold the content.
        - A pin label with an icon and text.
        - An "Add Year" button.
        - A section for displaying a quote and an image.
        - A vertical separator line between the quote and the image.

        :return: None
        """
        image_frame = tk.Frame(self, bg=INTERFACE['bg_color'])
        image_frame.pack(pady=5)

        # Pin frame
        pin_label_frame = tk.Frame(image_frame, bg=YEARLY_PLANS['pin_label_bg'])
        pin_label_frame.grid(row=0, column=0, padx=10, pady=5, sticky="nw")

        # Fetch pin_icon image from the server
        pin_icon_data = asyncio.run(add_icon_image(YEARLY_PLANS['pin_icon_path']))
        pin_icon = ImageTk.PhotoImage(pin_icon_data.resize((25, 25)))

        # Fetch smile_icon image from the server
        smile_icon_data = asyncio.run(add_icon_image(YEARLY_PLANS['smile_icon_path']))
        smile_icon = ImageTk.PhotoImage(smile_icon_data.resize((25, 25)))

        # Pin label
        pin_label_icon = tk.Label(pin_label_frame, image=pin_icon, bg=YEARLY_PLANS['pin_label_bg'])
        pin_label_icon.image = pin_icon
        pin_label_icon.pack(side=tk.LEFT, padx=(0, 5))

        # Text
        pin_text_label = tk.Label(pin_label_frame, text="Choose a year", font=YEARLY_PLANS['pin_frame_font'],
                                  fg=YEARLY_PLANS['pin_frame_text_color'],
                                  bg=YEARLY_PLANS['pin_label_bg'])
        pin_text_label.pack(side=tk.LEFT)

        # Smile icon
        smile_label_icon = tk.Label(pin_label_frame, image=smile_icon, bg=YEARLY_PLANS['pin_label_bg'])
        smile_label_icon.image = smile_icon
        smile_label_icon.pack(side=tk.LEFT, padx=(5, 0))

        # Add year button
        add_year_frame = tk.Frame(image_frame)
        add_year_frame.grid(row=1, column=0, padx=10, pady=(5, 0), sticky="nsew")

        add_year_button = tk.Button(add_year_frame, text="Add year", command=self.show_year_input,
                                    bg=YEARLY_PLANS['add_button_color'], font=YEARLY_PLANS['add_button_font'])
        add_year_button.pack(anchor="center")
        add_year_button.config(cursor="hand2")

        # Quote and image frame
        quote_with_image_frame = tk.Frame(image_frame, bg=INTERFACE['bg_color'])
        quote_with_image_frame.grid(row=0, column=1, rowspan=10, padx=10, pady=5, sticky="n")

        # Image
        add_image_to_grid(quote_with_image_frame, YEARLY_PLANS['image_link'], row=0, column=0, height=200,
                          width=300, rowspan=1, columnspan=1)

        quote_frame = tk.Frame(quote_with_image_frame, bg=INTERFACE['bg_color'])
        quote_frame.grid(row=1, column=0, sticky="n")

        # Increase the image load count
        self.image_load_count += 1

        # Vertical line
        line = tk.Canvas(quote_frame, width=2, bg=INTERFACE['separator'], height=100)
        line.grid(row=0, column=0, padx=(0, 10), sticky="n")

        # Quote text
        quote_text = YEARLY_PLANS['quote_text']
        label_quote = tk.Label(quote_frame, text=quote_text, font=YEARLY_PLANS['quote_font'],
                               bg=INTERFACE['bg_color'], wraplength=YEARLY_PLANS['quote_wraplength'])
        label_quote.grid(row=0, column=1, sticky="w")

        image_frame.pack(pady=5)

    def show_year_input(self):
        """
        Opens a dialog window that allows the user to enter a year and save it.

        The method creates a new top-level window for the user to input a year. The user can either press
        "Enter" or click the "Save" button to save the year. Once the user has entered a year, it is passed
        to the `add_year` method to be added.

        :return: None
        """
        dialog = tk.Toplevel(self)
        dialog.withdraw()
        dialog.title("Add Year")

        center_window_on_parent(self.main_window, dialog, 250, 150)
        dialog.iconbitmap(APP['icon_path'])

        tk.Label(dialog, text="Enter a year:", font=YEARLY_PLANS['toplevel_windows_font']).pack(pady=10)

        year_entry = tk.Entry(dialog, font=YEARLY_PLANS['toplevel_windows_font'])
        year_entry.pack(pady=5)
        year_entry.bind("<Return>", lambda event: asyncio.run(self.add_year(year_entry.get(), dialog)))

        # Save button
        ok_button = tk.Button(dialog, text="Save", command=lambda: asyncio.run(self.add_year(year_entry.get(), dialog)),
                              font=YEARLY_PLANS['toplevel_windows_font'])
        ok_button.pack(pady=10)
        ok_button.config(cursor="hand2")

        dialog.deiconify()

    async def add_year(self, year_input, dialog):
        """
        Adds a new year to the application by sending a request to the server.

        :param year_input: The input year as a string entered by the user.
        :param dialog: The dialog window where the user enters the year, which will be closed after the year is added.
        :return: None
        """
        if year_input and year_input.isdigit():  # Check if number
            year = int(year_input)

            # Check if year already exists
            if year in self.years_list:
                messagebox.showerror("Error", f"Year {year} already exists.")
                dialog.lift()
                return

            async with aiohttp.ClientSession() as session:
                try:
                    async with session.post(f"{SERVER_URL}/add_year", json={"year": year}, ssl=SSL_ENABLED) as response:
                        if response.status == 200:
                            # Создаем кнопку
                            year_button = tk.Button(
                                self.year_buttons_frame,
                                text=str(year),
                                command=lambda: self.open_year_page(year),
                                image=self.icon_photo,
                                compound=tk.LEFT,
                                font=("Arial", 12)
                            )
                            # Pack the new button at the top
                            year_button.pack(side=tk.TOP, pady=5, anchor="w")
                            year_button.config(cursor="hand2")

                            self.years_list.append(year)
                            self.year_buttons.append(year_button)

                            # Add tooltip
                            ToolTip(year_button, "Right click to edit/delete")
                            self.year_buttons.insert(0, year_button)  # Insert the button at the start of the list
                            self.bind_right_click_to_buttons()

                            # Rearrange the packing to ensure the new button is on top
                            self.rearrange_year_buttons()

                            dialog.destroy()
                        elif response.status == 400:
                            messagebox.showerror("Error", f"Year {year} already exists on the server.")
                            dialog.lift()
                        else:
                            messagebox.showerror("Error", "Failed to add year.")
                            dialog.lift()
                except Exception as e:
                    messagebox.showerror("Error", f"Server error: {e}")
                    dialog.destroy()
        else:
            messagebox.showerror("Error", "Please enter a valid year.")  # Show error if invalid year
            dialog.lift()

    def rearrange_year_buttons(self):
        """
        Rearranges the year buttons to ensure they are displayed in the correct order,
        with the most recent year appearing at the top.

        :return: None
        """
        # Clear all the year buttons from the frame
        for button in self.year_buttons:
            button.pack_forget()

        # Repack the buttons with the most recent year at the top
        for button in self.year_buttons:
            button.pack(side=tk.TOP, pady=5, anchor="w")

    def open_year_page(self, year):
        """
        Opens the page for the specified year, clears the main window's canvas, and displays the year's details.

        This method clears the main canvas of the current window and then creates a new instance of the `Year` class,
        passing the path to the server for the given year. It also makes sure the content is displayed
        in the main window. If a canvas exists, it scrolls it to the top; otherwise, it logs a message indicating no canvas is found.

        :param year: The year for which the page is to be opened.
        :return: None
        """
        self.main_window.clear_canvas()

        from src.year import Year
        year_frame = Year(self.parent, main_window=self.main_window, year=year)
        year_frame.pack(fill=tk.BOTH, expand=True)

        reset_canvas_view(self.main_window)
